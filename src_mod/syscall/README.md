## Syscall clear_ouichefs

Le numéro du syscall dans le kernel est 548. Afin de l'appeler, vous devrez appler la fonction *syscall(548, policy)*. Policy est un int. Si policy = 0, alors la politique de suppression de fichier sera biggest, si policy = 1 alors la politique sera oldest. Si un autre entier est donné en paramètre, la politique déjà en place sera choisie. Attention, après le syscall, la politique pré-syscall est restaurée. Si un entier passé ne vaut pas 1 ou 0, alors la politique en place est choisie par défaut. Il ne faut pas oublier d'inclure *#include <sys/syscall.h>*. Si le syscall renvoie une valeur différente de 0 alors le syscall à échoué.

Notre syscall a un problème lorsqu'on l'appelle sur une partition vide. Pour appeler clean_it() il nous faut une struct inode. Pour la récupérer, nous avons du récupérer le dentry lors du mount afin d'accèder au super_block car nous n'avons pas trouvé d'autres moyens de le faire. Nous donnons donc toujours l'inode 0 à clean_it(), s'il n'y a aucun fichier, on ne pourra pas supprimer l'inode 0 car cela supprimerait la racine. Cependant, il n'y aurait pas d'intérêt pour l'utilisateur d'appeler le syscall si sa partition est vide. 

Un autre problème avec notre syscall est que nous ne pouvons pas informer l'utilisateur de la suppression des fichiers. Nous arrivons seulement à faire des pr_info et pas de printf pour l'utilisateur. Si le syscall réussi, il ne saura pas quel fichier à été supprimé.
